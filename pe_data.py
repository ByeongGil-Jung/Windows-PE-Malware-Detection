import os

import numpy as np
import pefile


class PEData(object):

    DEFAULT_COLUMN_LIST = [
        'DIRECTORY_ENTRY_BASERELOC',
        'DIRECTORY_ENTRY_BOUND_IMPORT',
        'DIRECTORY_ENTRY_DEBUG',
        'DIRECTORY_ENTRY_DELAY_IMPORT',
        'DIRECTORY_ENTRY_EXCEPTION',
        'DIRECTORY_ENTRY_EXPORT',
        'DIRECTORY_ENTRY_IMPORT',
        'DIRECTORY_ENTRY_LOAD_CONFIG',
        'DIRECTORY_ENTRY_RESOURCE',
        'DIRECTORY_ENTRY_TLS',
        'DOS_HEADER',
        'FILE_HEADER',
        'FileAlignment_Warning',
        'FileInfo',
        'NT_HEADERS',
        'OPTIONAL_HEADER',
        'PE_TYPE',
        'RICH_HEADER',
        'SectionAlignment_Warning',
        'VS_FIXEDFILEINFO',
        'VS_VERSIONINFO',
        '_PE__from_file',
        '_PE__resource_size_limit_reached',
        '_PE__resource_size_limit_upperbounds',
        '_PE__total_import_symbols',
        '_PE__total_resource_bytes',
        '_PE__total_resource_entries_count',
        '_PE__warnings',
        '__data__',
        # '__structures__',
        'fileno',
        'header',
        'max_repeated_symbol',
        'max_symbol_exports',
        'sections'
    ]

    def __init__(self, pe_file_path, delimeter="-"):
        self.pe_file_path = pe_file_path
        self.pe_file_name = os.path.basename(pe_file_path)
        self.pe = pefile.PE(pe_file_path)
        self.delimeter = delimeter

    def get_feature_dict(self):
        feature_dict = dict()

        for column_name in PEData.DEFAULT_COLUMN_LIST:
            try:
                attribute_obj = self.pe.__dict__[column_name]

                if column_name == "DIRECTORY_ENTRY_IMPORT":
                    feature_str = ""

                    for attribute in attribute_obj:
                        value, is_required_attribute_convert, is_ignore = \
                            self.convert_value_by_type(value=attribute.dll)
                        feature_str = f"{feature_str} {value}"

                    feature_dict[column_name] = feature_str.strip()
                elif column_name == "DIRECTORY_ENTRY_DELAY_IMPORT":
                    feature_str = ""

                    for attribute in attribute_obj:
                        value, is_required_attribute_convert, is_ignore = \
                            self.convert_value_by_type(value=attribute.dll)
                        feature_str = f"{feature_str} {value}"

                    feature_dict[column_name] = feature_str.strip()
                elif column_name == "DIRECTORY_ENTRY_EXPORT":
                    feature_str = ""

                    value, is_required_attribute_convert, is_ignore = \
                        self.convert_value_by_type(value=attribute_obj.name)

                    feature_str = f"{feature_str} {value}"

                    feature_dict[column_name] = feature_str.strip()
                elif column_name == "DIRECTORY_ENTRY_DEBUG":
                    for attribute in attribute_obj:
                        feature_dict = self.do_convert(feature_name=column_name, feature_dict=feature_dict,
                                                   attribute_obj=attribute.entry)
                elif column_name == "DIRECTORY_ENTRY_RESOURCE":
                    feature_str = ""

                    if isinstance(attribute_obj, pefile.ResourceDirEntryData):
                        value, is_required_attribute_convert, is_ignore = \
                            self.convert_value_by_type(value=attribute_obj)

                        feature_str = f"{feature_str} {value}"
                    else:
                        for attribute in attribute_obj.entries:
                            value, is_required_attribute_convert, is_ignore = \
                                self.convert_value_by_type(value=attribute.id)
                            feature_str = f"{feature_str} {value}"

                    feature_dict[column_name] = feature_str.strip()
                elif column_name == "DIRECTORY_ENTRY_BOUND_IMPORT":
                    feature_str = ""

                    for attribute in attribute_obj:
                        value, is_required_attribute_convert, is_ignore = \
                            self.convert_value_by_type(value=attribute.name)
                        feature_str = f"{feature_str} {value}"

                    feature_dict[column_name] = feature_str.strip()
                elif column_name == "DIRECTORY_ENTRY_BASERELOC":
                    feature_size = 0

                    for outer_attribute in attribute_obj:
                        feature_size += len(outer_attribute.entries)

                    feature_dict[f"{column_name}_SIZE"] = feature_size
                elif column_name == "DIRECTORY_ENTRY_TLS":
                    feature_dict = self.do_convert(feature_name=column_name, feature_dict=feature_dict,
                                               attribute_obj=attribute_obj.struct)
                elif column_name == "DIRECTORY_ENTRY_LOAD_CONFIG":
                    feature_dict = self.do_convert(feature_name=column_name, feature_dict=feature_dict,
                                               attribute_obj=attribute_obj.struct)
                elif column_name == "DIRECTORY_ENTRY_EXCEPTION":  # exception 발생 시 1
                    feature_dict[f"IS_{column_name}"] = True
                elif column_name == "__data__":  # data size 측정
                    feature_dict[f"DATA_SIZE"] = len(attribute_obj)
                else:
                    feature_dict = self.do_convert(feature_name=column_name, feature_dict=feature_dict,
                                                    attribute_obj=attribute_obj)
            except Exception as e:
                pass

        return feature_dict

    def do_convert(self, feature_name, feature_dict, attribute_obj):
        if isinstance(attribute_obj, pefile.Structure):
            base_feature_name = f"{feature_name}{self.delimeter}{attribute_obj.name}"
            # self.set_feature(feature_name=current_feature_name, feature_dict=feature_dict, attribute=attribute_obj)
            for key, value in attribute_obj.__dict__.items():
                if key == "name":
                    continue
                if key[:2] != "__":
                    current_feature_name = f"{base_feature_name}{self.delimeter}{key}"
                    value, is_required_attribute_convert, is_ignore = self.convert_value_by_type(value=value)

                    if is_required_attribute_convert:
                        self.do_convert(feature_name=current_feature_name, feature_dict=feature_dict,
                                        attribute_obj=value)
                    if not is_ignore:
                        feature_dict[current_feature_name] = value

        if isinstance(attribute_obj, list):
            for attribute in attribute_obj:
                self.do_convert(feature_name=feature_name, feature_dict=feature_dict, attribute_obj=attribute)
        if isinstance(attribute_obj, dict):
            pass
        else:
            value, is_required_attribute_convert, is_ignore = self.convert_value_by_type(value=attribute_obj)

            if not is_ignore:
                feature_dict[feature_name] = value

        return feature_dict


    @classmethod
    def convert_value_by_type(cls, value):
        is_required_attribute_convert = False
        is_ignore = False
        converted_value = value

        # Check convert
        if isinstance(value, pefile.Structure):
            is_required_attribute_convert = True
        if isinstance(value, list):
            is_required_attribute_convert = True
        if isinstance(value, dict):
            is_ignore = True
            # is_required_attribute_convert = True

        # Convert value
        if isinstance(value, bytes):
            converted_value = value.decode('utf-8')

        return converted_value, is_required_attribute_convert, is_ignore

    @classmethod
    def calculate_default_column_set(cls, pe_file_path_list, size=100):
        column_set = set()

        size = size if size else len(pe_file_path_list)

        for pe_file_path in pe_file_path_list[:size]:
            try:
                pe = pefile.PE(pe_file_path)
                column_set.update(pe.__dict__.keys())
                # print(len(column_set))
            except Exception as e:
                pass

        return column_set

    @classmethod
    def remove_unused_feature(cls, feature_dict):

        removed_key_list = list()

        for key, value in feature_dict.items():
            is_removed = True

            if isinstance(value, str):
                is_removed = False
            if isinstance(value, int):
                is_removed = False
            if isinstance(value, float):
                is_removed = False
            if isinstance(value, bool):
                is_removed = False

            if is_removed:
                removed_key_list.append(key)

        # Remove
        for removed_key in removed_key_list:
            del feature_dict[removed_key]

        return feature_dict


class PeFeatureExtractor(object):

    def __init__(self, df):
        self.df = df
        self.label_list = list()
        self.file_name_list = list()

    def preprocessing_label(self):
        self.label_list = self.df.pop("LABEL")
        self.file_name_list = self.df.pop("FILE_NAME")

    def preprocessing_type(self):
        float_column_list = list()
        bool_column_list = list()
        obj_column_list = list()

        for column, dtype in zip(self.df.columns, self.df.dtypes):
            if dtype == np.int64 or dtype == np.float64:
                float_column_list.append(column)
            elif dtype == np.bool_:
                bool_column_list.append(column)
            else:
                obj_column_list.append(column)

        column_dtype_dict = dict(
            float_column_list=float_column_list,
            bool_column_list=bool_column_list,
            obj_column_list=obj_column_list,
        )

        # Convert float column
        for obj_column in column_dtype_dict["float_column_list"]:
            current_type = float
            self.df[obj_column] = self.df[obj_column].fillna(0).astype(current_type)

        # Convert bool column
        for obj_column in column_dtype_dict["bool_column_list"]:
            current_type = float
            self.df[obj_column] = self.df[obj_column].fillna(0).astype(current_type)

        # Convert object column
        for obj_column in column_dtype_dict["obj_column_list"]:
            column_value_set = set(self.df[obj_column].fillna(""))
            column_value_set.discard("")

            # Calculate all dtype
            dtype_set = set()

            for column_value in column_value_set:
                dtype_set.add(type(column_value))

            # Convert type
            if len(dtype_set) == 1:
                current_type = list(dtype_set)[0]

                if current_type == bool:
                    current_type = float
                    self.df[obj_column] = self.df[obj_column].fillna(False).astype(current_type)
                else:
                    self.df[obj_column] = self.df[obj_column].fillna("").astype(current_type)
            if len(dtype_set) == 2:
                if str in dtype_set and float in dtype_set:
                    current_type = float
                    self.df[obj_column] = self.df[obj_column].fillna(0).replace("", 0).astype(current_type)

    def get_numeric_str_df(self):
        numeric_column_list = list()
        str_column_list = list()

        for column, current_type in zip(self.df.columns, self.df.dtypes):

            if current_type == float or current_type == int:
                numeric_column_list.append(column)
            else:
                str_column_list.append(column)

        return self.df[numeric_column_list], self.df[str_column_list]


